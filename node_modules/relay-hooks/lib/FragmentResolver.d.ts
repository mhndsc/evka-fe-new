import { IEnvironment, Disposable, Snapshot, Variables, ReaderSelector, ReaderFragment } from 'relay-runtime';
import { Fetcher } from './FetchResolver';
import { FragmentNames, Options, OptionsLoadMore } from './RelayHooksTypes';
declare type SingularOrPluralSnapshot = Snapshot | Array<Snapshot>;
declare type FragmentResult = {
    snapshot?: SingularOrPluralSnapshot | null;
    data: any;
    isMissingData?: boolean;
    owner?: any;
};
export declare class FragmentResolver {
    _environment: IEnvironment;
    _fragment: ReaderFragment;
    _fragmentRef: any;
    _fragmentRefRefetch: any;
    _idfragment: any;
    _idfragmentrefetch: any;
    resolverData: FragmentResult;
    _disposable: Disposable;
    _selector: ReaderSelector;
    refreshHooks: any;
    fetcherRefecth: Fetcher;
    fetcherNext: Fetcher;
    fetcherPrevious: Fetcher;
    unmounted: boolean;
    name: string;
    refetchable: boolean;
    pagination: boolean;
    result: any;
    constructor(name: FragmentNames);
    setForceUpdate(forceUpdate: () => void): void;
    setUnmounted(): void;
    isEqualsFragmentRef(prevFragment: any, fragmentRef: any): boolean;
    dispose(): void;
    getFragmentVariables(fRef?: any): Variables;
    resolve(environment: IEnvironment, idfragment: string, fragment: ReaderFragment, fragmentRef: any): void;
    lookup(fragment: any, fragmentRef: any): void;
    checkAndSuspense(suspense: any): void;
    getData(): any | null;
    resolveResult(): any;
    unsubscribe(): void;
    subscribe(): void;
    refetch: (variables: Variables, options?: Options) => Disposable;
    loadPrevious: (count: number, options?: OptionsLoadMore<import("relay-runtime").OperationType>) => Disposable;
    loadNext: (count: number, options?: OptionsLoadMore<import("relay-runtime").OperationType>) => Disposable;
    loadMore: (direction: "forward" | "backward", count: number, options?: OptionsLoadMore<import("relay-runtime").OperationType>) => Disposable;
}
export {};
