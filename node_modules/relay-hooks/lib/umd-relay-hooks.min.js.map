{"version":3,"file":"umd-relay-hooks.min.js","sources":["../src/ReactRelayContext.ts","../src/Utils.ts","../src/FetchResolver.ts","../src/RelayHooksTypes.ts","../src/QueryFetcher.ts","../src/useForceUpdate.ts","../src/useRelayEnvironment.ts","../src/useQuery.ts","../src/loadQuery.ts","../node_modules/tslib/tslib.es6.js","../src/getValueAtPath.ts","../src/getConnectionState.ts","../src/getRefetchMetadata.ts","../src/getPaginationMetadata.ts","../src/FragmentResolver.ts","../src/getPaginationVariables.ts","../src/useOssFragment.tsx","../src/useMutation.ts","../src/RelayEnvironmentProvider.tsx","../src/useFragment.tsx","../src/usePagination.ts","../src/usePreloadedQuery.ts","../src/useRefetchable.ts","../src/useSubscription.ts"],"sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\n'use strict';\r\n\r\nimport * as React from 'react';\r\nimport { __internal } from 'relay-runtime';\r\n\r\nconst { createRelayContext } = __internal as any;\r\n\r\nexport const ReactRelayContext = createRelayContext(React);\r\n","import {\r\n    Variables,\r\n    ConnectionMetadata,\r\n    createOperationDescriptor,\r\n    getRequest,\r\n    GraphQLTaggedNode,\r\n    OperationDescriptor,\r\n    CacheConfig,\r\n} from 'relay-runtime';\r\nimport { STORE_OR_NETWORK, STORE_THEN_NETWORK, NETWORK_ONLY, FetchPolicy } from './RelayHooksTypes';\r\n\r\nexport type ReactConnectionMetadata = ConnectionMetadata & { fragmentName: string };\r\n\r\nexport const isNetworkPolicy = (policy: FetchPolicy, full: boolean): boolean => {\r\n    return (\r\n        policy === NETWORK_ONLY ||\r\n        policy === STORE_THEN_NETWORK ||\r\n        (policy === STORE_OR_NETWORK && !full)\r\n    );\r\n};\r\n\r\nexport const isStorePolicy = (policy: FetchPolicy): boolean => {\r\n    return policy !== NETWORK_ONLY;\r\n};\r\n\r\nexport const forceCache = { force: true };\r\n\r\n// Fetcher\r\nexport function createOperation(\r\n    gqlQuery: GraphQLTaggedNode,\r\n    variables: Variables,\r\n    cacheConfig?: CacheConfig | null,\r\n): OperationDescriptor {\r\n    return createOperationDescriptor(getRequest(gqlQuery), variables, cacheConfig);\r\n}\r\n","import {\r\n    __internal,\r\n    Disposable,\r\n    FetchPolicy,\r\n    Subscription,\r\n    OperationDescriptor,\r\n    IEnvironment,\r\n    Snapshot,\r\n    RenderPolicy,\r\n} from 'relay-runtime';\r\nimport { isNetworkPolicy, isStorePolicy } from './Utils';\r\nconst { fetchQuery } = __internal;\r\nconst DATA_RETENTION_TIMEOUT = 30 * 1000;\r\n\r\nexport type Fetcher = {\r\n    fetch: (\r\n        environment: IEnvironment,\r\n        operation: OperationDescriptor,\r\n        fetchPolicy: FetchPolicy | null | undefined,\r\n        onComplete: (_e: Error | null) => void,\r\n        onNext: (\r\n            operation: OperationDescriptor,\r\n            snapshot: Snapshot,\r\n            fromStore?: boolean,\r\n            onlyStore?: boolean,\r\n        ) => void,\r\n        renderPolicy?: RenderPolicy,\r\n    ) => Disposable;\r\n    getData: () => {\r\n        isLoading: boolean;\r\n        error?: Error | null;\r\n    };\r\n    dispose: () => void;\r\n    checkAndSuspense: (suspense: boolean, useLazy?: boolean) => Promise<any> | Error | null;\r\n};\r\n\r\nexport function fetchResolver({\r\n    setLoading,\r\n    doRetain = true,\r\n    disposeTemporary,\r\n}: {\r\n    doRetain?: boolean;\r\n    setLoading?: (loading: boolean) => void;\r\n    disposeTemporary?: () => void;\r\n}): Fetcher {\r\n    let _refetchSubscription: Subscription | null = null;\r\n    let disposable: Disposable | null = null;\r\n    let releaseQueryTimeout;\r\n    let isLoading = false;\r\n    let query;\r\n    let promise: Promise<any>;\r\n    let error: Error | null = null;\r\n    let env;\r\n\r\n    const updateLoading = (loading: boolean): void => {\r\n        isLoading = loading;\r\n        setLoading && setLoading(isLoading);\r\n    };\r\n    const lookupInStore = (\r\n        environment: IEnvironment,\r\n        operation,\r\n        fetchPolicy,\r\n        renderPolicy: RenderPolicy,\r\n    ): { snapshot: Snapshot | null; full: boolean } => {\r\n        if (isStorePolicy(fetchPolicy)) {\r\n            const check = environment.check(operation);\r\n            const queryStatus = check.status;\r\n            const hasFullQuery = queryStatus === 'available';\r\n            const canPartialRender =\r\n                hasFullQuery || (renderPolicy === 'partial' && queryStatus !== 'stale');\r\n            if (canPartialRender) {\r\n                return { snapshot: environment.lookup(operation.fragment), full: hasFullQuery };\r\n            }\r\n        }\r\n        return { snapshot: null, full: false };\r\n    };\r\n\r\n    const dispose = (): void => {\r\n        clearTemporaryRetain();\r\n        disposable && disposable.dispose();\r\n        disposeRequest();\r\n        disposable = null;\r\n        env = null;\r\n        query = null;\r\n    };\r\n\r\n    const clearTemporaryRetain = (): void => {\r\n        clearTimeout(releaseQueryTimeout);\r\n        releaseQueryTimeout = null;\r\n    };\r\n\r\n    const temporaryRetain = (): void => {\r\n        const localReleaseTemporaryRetain = (): void => {\r\n            clearTemporaryRetain();\r\n            dispose();\r\n            disposeTemporary && disposeTemporary();\r\n        };\r\n        releaseQueryTimeout = setTimeout(localReleaseTemporaryRetain, DATA_RETENTION_TIMEOUT);\r\n    };\r\n\r\n    const disposeRequest = (): void => {\r\n        _refetchSubscription && _refetchSubscription.unsubscribe();\r\n        error = null;\r\n    };\r\n\r\n    const fetch = (\r\n        environment: IEnvironment,\r\n        operation: OperationDescriptor,\r\n        fetchPolicy: FetchPolicy = 'network-only',\r\n        onComplete = (_e: Error | null): void => undefined,\r\n        onNext: (\r\n            operation: OperationDescriptor,\r\n            snapshot: Snapshot,\r\n            fromStore?: boolean,\r\n            onlyStore?: boolean,\r\n        ) => void,\r\n        renderPolicy?: RenderPolicy,\r\n    ): Disposable => {\r\n        if (env != environment || query.request.identifier !== operation.request.identifier) {\r\n            dispose();\r\n            if (doRetain) {\r\n                disposable = environment.retain(operation);\r\n            }\r\n        }\r\n        env = environment;\r\n        query = operation;\r\n\r\n        disposeRequest();\r\n        const { snapshot, full } = lookupInStore(environment, operation, fetchPolicy, renderPolicy);\r\n        const isNetwork = isNetworkPolicy(fetchPolicy, full);\r\n        if (snapshot != null) {\r\n            const onlyStore = !isNetwork;\r\n            onNext(operation, snapshot, true, onlyStore);\r\n            if (onlyStore) {\r\n                onComplete(null);\r\n            }\r\n        }\r\n        // Cancel any previously running refetch.\r\n        _refetchSubscription && _refetchSubscription.unsubscribe();\r\n        if (isNetwork) {\r\n            let resolveNetworkPromise = (): void => {};\r\n\r\n            // Declare refetchSubscription before assigning it in .start(), since\r\n            // synchronous completion may call callbacks .subscribe() returns.\r\n            let refetchSubscription: Subscription;\r\n            const cleanup = (): void => {\r\n                if (_refetchSubscription === refetchSubscription) {\r\n                    _refetchSubscription = null;\r\n                }\r\n                isLoading = false;\r\n                promise = null;\r\n            };\r\n\r\n            fetchQuery(environment, operation).subscribe({\r\n                unsubscribe: (): void => {\r\n                    cleanup();\r\n                },\r\n                complete: (): void => {\r\n                    resolveNetworkPromise();\r\n                    updateLoading(false);\r\n                    cleanup();\r\n                    onComplete(null);\r\n                },\r\n                error: (e: Error): void => {\r\n                    error = e;\r\n                    resolveNetworkPromise();\r\n                    updateLoading(false);\r\n                    cleanup();\r\n                    onComplete(e);\r\n                },\r\n                next: () => {\r\n                    const store = environment.lookup(operation.fragment);\r\n                    promise = null;\r\n                    operation.request.cacheConfig?.poll && updateLoading(false);\r\n                    resolveNetworkPromise();\r\n                    onNext(operation, store);\r\n                },\r\n                start: (subscription) => {\r\n                    refetchSubscription = subscription;\r\n                    _refetchSubscription = refetchSubscription;\r\n                    updateLoading(true);\r\n                },\r\n            });\r\n            if (!snapshot) {\r\n                promise = new Promise((resolve: any) => {\r\n                    resolveNetworkPromise = resolve;\r\n                });\r\n            }\r\n            return {\r\n                dispose: (): void => {\r\n                    refetchSubscription && refetchSubscription.unsubscribe();\r\n                },\r\n            };\r\n        }\r\n        return {\r\n            dispose: (): void => {},\r\n        };\r\n    };\r\n\r\n    const checkAndSuspense = (suspense, useLazy): Promise<any> | Error | null => {\r\n        clearTemporaryRetain();\r\n        const toThrow = promise || error;\r\n        if (suspense && toThrow) {\r\n            if (promise && useLazy) {\r\n                temporaryRetain();\r\n            }\r\n            throw toThrow;\r\n        }\r\n        return toThrow;\r\n    };\r\n\r\n    const getData = (): {\r\n        isLoading: boolean;\r\n        error?: Error | null;\r\n    } => {\r\n        return {\r\n            isLoading,\r\n            error,\r\n        };\r\n    };\r\n\r\n    return {\r\n        fetch,\r\n        getData,\r\n        dispose,\r\n        checkAndSuspense,\r\n    };\r\n}\r\n","import {\r\n    Disposable,\r\n    OperationType,\r\n    CacheConfig,\r\n    GraphQLTaggedNode,\r\n    IEnvironment,\r\n    MutationConfig as BaseMutationConfig,\r\n    MutationParameters,\r\n    FragmentSpecResolver,\r\n    VariablesOf,\r\n    FragmentReference,\r\n    RenderPolicy,\r\n    GraphQLSubscriptionConfig,\r\n} from 'relay-runtime';\r\n\r\nexport type MutationState<T extends MutationParameters> = {\r\n    loading: boolean;\r\n    data: T['response'] | null;\r\n    error?: Error | null;\r\n};\r\n\r\nexport type MutationNode<T extends MutationParameters> = BaseMutationConfig<T>['mutation'];\r\n\r\nexport type MutationConfig<T extends MutationParameters> = Partial<\r\n    Omit<BaseMutationConfig<T>, 'mutation' | 'onCompleted'>\r\n> & {\r\n    onCompleted?(response: T['response']): void;\r\n};\r\n\r\nexport type MutationConfigWithoutVariables<T extends MutationParameters> = Omit<\r\n    MutationConfig<T>,\r\n    'variables'\r\n>;\r\n\r\nexport type Mutate<T extends MutationParameters> = (\r\n    config?: Partial<MutationConfig<T>>,\r\n) => Promise<T['response']>;\r\n\r\nexport type MutateWithVariables<T extends MutationParameters> = (\r\n    config: Partial<MutationConfig<T>> & { variables: T['variables'] },\r\n) => Promise<T['response']>;\r\n\r\nexport const NETWORK_ONLY = 'network-only';\r\nexport const STORE_THEN_NETWORK = 'store-and-network';\r\nexport const STORE_OR_NETWORK = 'store-or-network';\r\nexport const STORE_ONLY = 'store-only';\r\n\r\nexport const PAGINATION_NAME = 'usePagination';\r\nexport const REFETCHABLE_NAME = 'useRefetchable';\r\nexport const FRAGMENT_NAME = 'useFragment';\r\n\r\nexport type FragmentNames = typeof PAGINATION_NAME | typeof REFETCHABLE_NAME | typeof FRAGMENT_NAME;\r\n\r\nexport type FetchPolicy =\r\n    | typeof STORE_ONLY\r\n    | typeof STORE_OR_NETWORK\r\n    | typeof STORE_THEN_NETWORK\r\n    | typeof NETWORK_ONLY;\r\n\r\nexport type ContainerResult = {\r\n    data: { [key: string]: any };\r\n    resolver: FragmentSpecResolver;\r\n};\r\n\r\nexport interface RenderProps<T extends OperationType> {\r\n    error: Error | null;\r\n    data: T['response'] | null | undefined;\r\n    retry: (_cacheConfigOverride?: CacheConfig, options?: Options) => void;\r\n    isLoading: boolean;\r\n}\r\n\r\nexport type QueryOptions = {\r\n    fetchPolicy?: FetchPolicy;\r\n    fetchKey?: string | number;\r\n    networkCacheConfig?: CacheConfig;\r\n    skip?: boolean;\r\n    onComplete?: (_e: Error | null) => void;\r\n    UNSTABLE_renderPolicy?: RenderPolicy;\r\n};\r\n\r\nexport type $Call<Fn extends (...args: any[]) => any> = Fn extends (arg: any) => infer RT\r\n    ? RT\r\n    : never;\r\n\r\nexport type KeyType<TData = unknown> = Readonly<{\r\n    ' $data'?: TData;\r\n    ' $fragmentRefs': FragmentReference;\r\n}>;\r\nexport type ArrayKeyType = ReadonlyArray<{ readonly ' $data'?: ReadonlyArray<unknown> } | null>;\r\n\r\nexport type KeyTypeData<TKey extends KeyType<TData>, TData = unknown> = Required<TKey>[' $data'];\r\n\r\nexport type KeyReturnType<T extends KeyType> = (arg: T) => NonNullable<T[' $data']>;\r\nexport type ArrayKeyReturnType<T extends ArrayKeyType> = (\r\n    arg: T,\r\n) => NonNullable<NonNullable<T[0]>[' $data']>[0];\r\n\r\nexport type LoadMoreFn<TQuery extends OperationType = OperationType> = (\r\n    count: number,\r\n    options?: OptionsLoadMore<TQuery>,\r\n) => Disposable;\r\n\r\n// pagination\r\n\r\nexport const FORWARD = 'forward';\r\n\r\nexport type LoadQuery<\r\n    TOperationType extends OperationType = OperationType,\r\n    TEnvironment extends IEnvironment = IEnvironment\r\n> = {\r\n    next: (\r\n        environment: TEnvironment,\r\n        gqlQuery: GraphQLTaggedNode,\r\n        variables?: TOperationType['variables'],\r\n        options?: QueryOptions,\r\n    ) => Promise<void>;\r\n    subscribe: (callback: () => any) => () => void;\r\n    getValue: (environment?: TEnvironment) => RenderProps<TOperationType> | Promise<any>;\r\n    dispose: () => void;\r\n};\r\n\r\n// refetchable\r\n\r\nexport interface Options {\r\n    fetchPolicy?: FetchPolicy;\r\n    onComplete?: (arg: Error | null) => void;\r\n    UNSTABLE_renderPolicy?: RenderPolicy;\r\n}\r\n\r\nexport interface OptionsLoadMore<TQuery extends OperationType = OperationType> {\r\n    //fetchPolicy?: FetchPolicy;\r\n    onComplete?: (arg: Error | null) => void;\r\n    UNSTABLE_extraVariables?: VariablesOf<TQuery>;\r\n}\r\n\r\n// NOTE: RefetchFnDynamic returns a refetch function that:\r\n//  - Expects the /exact/ set of query variables if the provided key type is\r\n//    /nullable/.\r\n//  - Or, expects /a subset/ of the query variables if the provided key type is\r\n//    /non-null/.\r\nexport type RefetchFnDynamic<\r\n    TQuery extends OperationType,\r\n    TKey extends KeyType | null,\r\n    TOptions = Options\r\n> = RefetchInexactDynamicResponse<TQuery, TOptions> & RefetchExactDynamicResponse<TQuery, TOptions>;\r\n\r\nexport type RefetchInexact<TQuery extends OperationType, TOptions> = (\r\n    data?: unknown,\r\n) => RefetchFnInexact<TQuery, TOptions>;\r\nexport type RefetchInexactDynamicResponse<TQuery extends OperationType, TOptions> = ReturnType<\r\n    RefetchInexact<TQuery, TOptions>\r\n>;\r\n\r\nexport type RefetchExact<TQuery extends OperationType, TOptions> = (\r\n    data?: unknown | null,\r\n) => RefetchFnExact<TQuery, TOptions>;\r\nexport type RefetchExactDynamicResponse<TQuery extends OperationType, TOptions> = ReturnType<\r\n    RefetchExact<TQuery, TOptions>\r\n>;\r\n\r\nexport type RefetchFnBase<TVars, TOptions> = (vars: TVars, options?: TOptions) => Disposable;\r\n\r\nexport type RefetchFnExact<TQuery extends OperationType, TOptions = Options> = RefetchFnBase<\r\n    VariablesOf<TQuery>,\r\n    TOptions\r\n>;\r\nexport type RefetchFnInexact<TQuery extends OperationType, TOptions = Options> = RefetchFnBase<\r\n    Partial<VariablesOf<TQuery>>,\r\n    TOptions\r\n>;\r\n\r\nexport interface ReturnTypeRefetchNode<\r\n    TQuery extends OperationType,\r\n    TKey extends KeyType | null,\r\n    TFragmentData\r\n> extends ReturnTypeRefetchSuspenseNode<TQuery, TKey, TFragmentData> {\r\n    isLoading: boolean;\r\n    error: Error | null;\r\n}\r\n\r\nexport type ReturnTypeRefetchSuspenseNode<\r\n    TQuery extends OperationType,\r\n    TKey extends KeyType | null,\r\n    TFragmentData\r\n> = { data: TFragmentData; refetch: RefetchFnDynamic<TQuery, TKey> };\r\n\r\n// pagination\r\n\r\nexport interface ReturnTypePagination<\r\n    TQuery extends OperationType,\r\n    TKey extends KeyType | null,\r\n    TFragmentData\r\n> extends ReturnTypePaginationSuspense<TQuery, TKey, TFragmentData> {\r\n    isLoading: boolean;\r\n    error: Error | null;\r\n}\r\n\r\nexport interface ReturnTypePaginationSuspense<\r\n    TQuery extends OperationType,\r\n    TKey extends KeyType | null,\r\n    TFragmentData\r\n> {\r\n    data: TFragmentData;\r\n    loadNext: LoadMoreFn<TQuery>;\r\n    loadPrevious: LoadMoreFn<TQuery>;\r\n    hasNext: boolean;\r\n    hasPrevious: boolean;\r\n    isLoadingNext: boolean;\r\n    isLoadingPrevious: boolean;\r\n    errorNext: Error | null;\r\n    errorPrevious: Error | null;\r\n    refetch: RefetchFnDynamic<TQuery, TKey>;\r\n}\r\n\r\nexport type SubscriptionConfig = {\r\n    skip?: boolean;\r\n};\r\n\r\nexport type SkipSubscriptionConfig = {\r\n    skip: true;\r\n};\r\n\r\nexport interface SkipGraphQLSubscriptionConfig<TSubscription extends OperationType>\r\n    extends Omit<GraphQLSubscriptionConfig<TSubscription>, 'variables' | 'subscription'> {\r\n    subscription?: GraphQLSubscriptionConfig<TSubscription>['subscription'];\r\n    variables?: TSubscription['variables'];\r\n}\r\n","import * as areEqual from 'fbjs/lib/areEqual';\r\nimport {\r\n    Disposable,\r\n    CacheConfig,\r\n    IEnvironment,\r\n    Snapshot,\r\n    OperationType,\r\n    OperationDescriptor,\r\n    GraphQLTaggedNode,\r\n    Variables,\r\n} from 'relay-runtime';\r\nimport { Fetcher, fetchResolver } from './FetchResolver';\r\nimport { FetchPolicy, RenderProps, QueryOptions, Options } from './RelayHooksTypes';\r\nimport { createOperation } from './Utils';\r\n\r\nconst defaultPolicy = 'store-or-network';\r\n\r\nconst cache: Map<string, QueryFetcher<any>> = new Map();\r\n\r\nexport function getOrCreateQueryFetcher<TOperationType extends OperationType>(\r\n    useLazy: boolean,\r\n    gqlQuery: GraphQLTaggedNode,\r\n    variables: TOperationType['variables'],\r\n    networkCacheConfig: CacheConfig,\r\n): QueryFetcher<TOperationType> {\r\n    const query = createOperation(gqlQuery, variables, networkCacheConfig);\r\n    const toGet = useLazy && cache.has(query.request.identifier);\r\n    const queryFetcher = toGet ? cache.get(query.request.identifier) : new QueryFetcher();\r\n    queryFetcher.setQuery(gqlQuery, variables, networkCacheConfig, query);\r\n    return queryFetcher;\r\n}\r\n\r\nconst emptyforceUpdate = (): void => undefined;\r\n\r\nexport class QueryFetcher<TOperationType extends OperationType = OperationType> {\r\n    environment: IEnvironment;\r\n    query: OperationDescriptor;\r\n    fetcher: Fetcher;\r\n    rootSubscription: Disposable;\r\n    snapshot: Snapshot;\r\n    fetchPolicy: FetchPolicy;\r\n    fetchKey: string | number;\r\n    variables: Variables;\r\n    cacheConfig: Variables;\r\n    gqlQuery: GraphQLTaggedNode;\r\n    options: QueryOptions;\r\n    forceUpdate = emptyforceUpdate;\r\n    result: RenderProps<TOperationType> = null;\r\n    skip?: boolean;\r\n\r\n    constructor() {\r\n        this.result = {\r\n            retry: this.retry,\r\n            error: null,\r\n            data: null,\r\n            isLoading: false,\r\n        };\r\n        this.fetcher = fetchResolver({\r\n            disposeTemporary: () => {\r\n                this.dispose();\r\n                this.query && cache.delete(this.query.request.identifier);\r\n            },\r\n        });\r\n    }\r\n\r\n    setQuery(\r\n        gqlQuery: GraphQLTaggedNode,\r\n        variables: TOperationType['variables'],\r\n        networkCacheConfig: CacheConfig,\r\n        query: OperationDescriptor,\r\n    ): void {\r\n        this.gqlQuery = gqlQuery;\r\n        this.variables = variables;\r\n        this.query = query;\r\n        this.cacheConfig = networkCacheConfig;\r\n    }\r\n\r\n    getForceUpdate(): () => void {\r\n        return this.forceUpdate;\r\n    }\r\n\r\n    setForceUpdate(forceUpdate): void {\r\n        this.forceUpdate = forceUpdate;\r\n    }\r\n\r\n    dispose(): void {\r\n        this.fetcher.dispose();\r\n        this.disposeSnapshot();\r\n    }\r\n\r\n    disposeSnapshot(): void {\r\n        this.snapshot = null;\r\n        if (this.rootSubscription) {\r\n            this.rootSubscription.dispose();\r\n            this.rootSubscription = null;\r\n        }\r\n    }\r\n\r\n    retry = (cacheConfigOverride?: CacheConfig | null, options: Options = {}): void => {\r\n        const { fetchPolicy = 'network-only' } = options;\r\n        /* eslint-disable indent */\r\n        const query = cacheConfigOverride\r\n            ? createOperation(\r\n                  this.query.request.node,\r\n                  this.query.request.variables,\r\n                  cacheConfigOverride,\r\n              )\r\n            : this.query;\r\n        this.fetch(query, fetchPolicy, options);\r\n        this.resolveResult();\r\n        this.forceUpdate();\r\n    };\r\n\r\n    fetch(\r\n        query: OperationDescriptor,\r\n        fetchPolicy: FetchPolicy,\r\n        options: Options,\r\n        skip?: boolean,\r\n    ): void {\r\n        this.disposeSnapshot();\r\n        if (skip) {\r\n            this.fetcher.dispose();\r\n            return;\r\n        }\r\n        // eslint-disable-next-line @typescript-eslint/camelcase\r\n        const { onComplete } = options;\r\n        let fetchHasReturned = false;\r\n        const onNext = (_o: OperationDescriptor, snapshot: Snapshot): void => {\r\n            if (!this.snapshot) {\r\n                this.snapshot = snapshot;\r\n                this.subscribe(snapshot);\r\n                this.resolveResult();\r\n                if (fetchHasReturned) {\r\n                    this.forceUpdate();\r\n                }\r\n            }\r\n        };\r\n        const complete = (error: Error | null): void => {\r\n            this.resolveResult();\r\n            if (fetchHasReturned) {\r\n                this.forceUpdate();\r\n            }\r\n            onComplete && onComplete(error);\r\n        };\r\n        this.fetcher.fetch(this.environment, query, fetchPolicy, complete, onNext);\r\n        fetchHasReturned = true;\r\n    }\r\n\r\n    getQuery(gqlQuery, variables, networkCacheConfig): OperationDescriptor | null {\r\n        if (\r\n            gqlQuery != this.gqlQuery ||\r\n            networkCacheConfig != this.cacheConfig ||\r\n            variables != this.variables ||\r\n            !areEqual(variables, this.variables)\r\n        ) {\r\n            this.variables = variables;\r\n            this.gqlQuery = gqlQuery;\r\n            this.cacheConfig = networkCacheConfig;\r\n            return createOperation(gqlQuery, variables, networkCacheConfig);\r\n        }\r\n        return this.query;\r\n    }\r\n\r\n    resolveEnvironment(environment: IEnvironment): void {\r\n        this.resolve(environment, this.gqlQuery, this.variables, this.options);\r\n    }\r\n\r\n    resolve(\r\n        environment: IEnvironment,\r\n        gqlQuery: GraphQLTaggedNode,\r\n        variables: Variables,\r\n        options: QueryOptions,\r\n    ): void {\r\n        const query = this.getQuery(gqlQuery, variables, options.networkCacheConfig);\r\n        const { fetchPolicy = defaultPolicy, fetchKey, skip } = options;\r\n        this.options = options;\r\n        const diffQuery = !this.query || query.request.identifier !== this.query.request.identifier;\r\n        if (\r\n            diffQuery ||\r\n            environment !== this.environment ||\r\n            fetchPolicy !== this.fetchPolicy ||\r\n            fetchKey !== this.fetchKey ||\r\n            skip !== this.skip\r\n        ) {\r\n            this.environment = environment;\r\n            this.query = query;\r\n            this.skip = skip;\r\n            this.fetchPolicy = fetchPolicy;\r\n            this.fetchKey = fetchKey;\r\n            this.fetch(query, fetchPolicy, options, skip);\r\n            this.resolveResult();\r\n        }\r\n    }\r\n\r\n    checkAndSuspense(suspense?: boolean, useLazy?: boolean): Promise<any> | Error | null {\r\n        if (useLazy) {\r\n            this.setForceUpdate(emptyforceUpdate);\r\n            cache.set(this.query.request.identifier, this);\r\n        }\r\n        const result = this.fetcher.checkAndSuspense(suspense, useLazy);\r\n        if (useLazy) {\r\n            cache.delete(this.query.request.identifier);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    getData(): RenderProps<TOperationType> {\r\n        return this.result;\r\n    }\r\n\r\n    resolveResult(): void {\r\n        const { error, isLoading } = this.fetcher.getData();\r\n        this.result = {\r\n            retry: this.retry,\r\n            error,\r\n            data: this.snapshot ? this.snapshot.data : null,\r\n            isLoading,\r\n        };\r\n    }\r\n\r\n    subscribe(snapshot): void {\r\n        if (this.rootSubscription) {\r\n            this.rootSubscription.dispose();\r\n        }\r\n        this.rootSubscription = this.environment.subscribe(snapshot, (snapshot) => {\r\n            // Read from this._fetchOptions in case onDataChange() was lazily added.\r\n            this.snapshot = snapshot;\r\n            //this.error = null;\r\n\r\n            this.resolveResult();\r\n            this.forceUpdate();\r\n        });\r\n    }\r\n}\r\n","import { Reducer, useReducer } from 'react';\r\n\r\nexport function useForceUpdate(): () => void {\r\n    const [, forceUpdate] = useReducer<Reducer<number, void>>((x) => x + 1, 0);\r\n    return forceUpdate as () => void;\r\n}\r\n","import * as React from 'react';\r\nimport { IEnvironment } from 'relay-runtime';\r\nimport { ReactRelayContext } from './ReactRelayContext';\r\n\r\nexport function useRelayEnvironment<\r\n    TEnvironment extends IEnvironment = IEnvironment\r\n>(): TEnvironment {\r\n    const { environment } = React.useContext(ReactRelayContext);\r\n    return environment;\r\n}\r\n","import { useRef, useEffect } from 'react';\r\nimport { GraphQLTaggedNode, OperationType } from 'relay-runtime';\r\nimport { getOrCreateQueryFetcher, QueryFetcher } from './QueryFetcher';\r\nimport { RenderProps, QueryOptions } from './RelayHooksTypes';\r\nimport { useForceUpdate } from './useForceUpdate';\r\nimport { useRelayEnvironment } from './useRelayEnvironment';\r\nimport { forceCache } from './Utils';\r\n\r\ntype Reference<TOperationType extends OperationType = OperationType> = {\r\n    queryFetcher: QueryFetcher<TOperationType>;\r\n};\r\n\r\nconst useInternalQuery = <TOperationType extends OperationType = OperationType>(\r\n    gqlQuery: GraphQLTaggedNode,\r\n    variables: TOperationType['variables'],\r\n    options: QueryOptions,\r\n    suspense: boolean,\r\n): RenderProps<TOperationType> => {\r\n    const environment = useRelayEnvironment();\r\n    const forceUpdate = useForceUpdate();\r\n    const ref = useRef<Reference<TOperationType>>();\r\n    if (ref.current === null || ref.current === undefined) {\r\n        ref.current = {\r\n            queryFetcher: getOrCreateQueryFetcher(\r\n                suspense,\r\n                gqlQuery,\r\n                variables,\r\n                options.networkCacheConfig,\r\n            ),\r\n        };\r\n    }\r\n\r\n    useEffect(() => {\r\n        return (): void => ref.current.queryFetcher.dispose();\r\n    }, []);\r\n\r\n    const { queryFetcher } = ref.current;\r\n    queryFetcher.resolve(environment, gqlQuery, variables, options);\r\n    queryFetcher.checkAndSuspense(suspense, suspense);\r\n    queryFetcher.setForceUpdate(forceUpdate);\r\n    return queryFetcher.getData();\r\n};\r\n\r\nexport const useQuery = <TOperationType extends OperationType = OperationType>(\r\n    gqlQuery: GraphQLTaggedNode,\r\n    variables: TOperationType['variables'] = {},\r\n    options: QueryOptions = {},\r\n): RenderProps<TOperationType> => {\r\n    return useInternalQuery(gqlQuery, variables, options, false);\r\n};\r\n\r\nexport const useLazyLoadQuery = <TOperationType extends OperationType = OperationType>(\r\n    gqlQuery: GraphQLTaggedNode,\r\n    variables: TOperationType['variables'] = {},\r\n    options: QueryOptions = {},\r\n): RenderProps<TOperationType> => {\r\n    options.networkCacheConfig = options.networkCacheConfig ?? forceCache;\r\n    return useInternalQuery(gqlQuery, variables, options, true);\r\n};\r\n","import { GraphQLTaggedNode, OperationType, IEnvironment } from 'relay-runtime';\r\nimport { QueryFetcher } from './QueryFetcher';\r\nimport { RenderProps, QueryOptions, LoadQuery } from './RelayHooksTypes';\r\nimport { forceCache } from './Utils';\r\n\r\nconst emptyFunction = (): void => undefined;\r\n\r\nexport const internalLoadQuery = <TOperationType extends OperationType = OperationType>(\r\n    promise = false,\r\n): LoadQuery<TOperationType> => {\r\n    let queryFetcher = new QueryFetcher<TOperationType>();\r\n\r\n    const dispose = (): void => {\r\n        queryFetcher.dispose();\r\n        queryFetcher.setForceUpdate(emptyFunction);\r\n        queryFetcher = new QueryFetcher<TOperationType>();\r\n    };\r\n\r\n    const next = (\r\n        environment,\r\n        gqlQuery: GraphQLTaggedNode,\r\n        variables: TOperationType['variables'] = {},\r\n        options: QueryOptions = {},\r\n    ): Promise<void> => {\r\n        options.networkCacheConfig = options.networkCacheConfig ?? forceCache;\r\n        queryFetcher.resolve(environment, gqlQuery, variables, options);\r\n        const toThrow = queryFetcher.checkAndSuspense();\r\n        return toThrow\r\n            ? toThrow instanceof Error\r\n                ? Promise.reject(toThrow)\r\n                : toThrow\r\n            : Promise.resolve();\r\n    };\r\n\r\n    const getValue = (\r\n        environment?: IEnvironment,\r\n    ): RenderProps<TOperationType> | null | Promise<any> => {\r\n        queryFetcher.resolveEnvironment(environment);\r\n        queryFetcher.checkAndSuspense(promise);\r\n        return queryFetcher.getData();\r\n    };\r\n\r\n    const subscribe = (callback: () => any): (() => void) => {\r\n        queryFetcher.setForceUpdate(callback);\r\n        return (): void => {\r\n            if (queryFetcher.getForceUpdate() === callback) {\r\n                queryFetcher.setForceUpdate(emptyFunction);\r\n            }\r\n        };\r\n    };\r\n    return {\r\n        next,\r\n        subscribe,\r\n        getValue,\r\n        dispose,\r\n    };\r\n};\r\n\r\nexport const loadLazyQuery = <\r\n    TOperationType extends OperationType = OperationType\r\n>(): LoadQuery<TOperationType> => {\r\n    return internalLoadQuery(true);\r\n};\r\n\r\nexport const loadQuery = <\r\n    TOperationType extends OperationType = OperationType\r\n>(): LoadQuery<TOperationType> => {\r\n    return internalLoadQuery(false);\r\n};\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import * as invariant from 'fbjs/lib/invariant';\r\n\r\nexport function getValueAtPath(data: any, path: ReadonlyArray<string | number>): any {\r\n    let result = data;\r\n    for (const key of path) {\r\n        if (result == null) {\r\n            return null;\r\n        }\r\n        if (typeof key === 'number') {\r\n            invariant(\r\n                Array.isArray(result),\r\n                'Relay: Expected an array when extracting value at path. ' +\r\n                    \"If you're seeing this, this is likely a bug in Relay.\",\r\n            );\r\n            result = result[key];\r\n        } else {\r\n            invariant(\r\n                typeof result === 'object' && !Array.isArray(result),\r\n                'Relay: Expected an object when extracting value at path. ' +\r\n                    \"If you're seeing this, this is likely a bug in Relay.\",\r\n            );\r\n            result = result[key];\r\n        }\r\n    }\r\n    return result;\r\n}\r\n","import * as invariant from 'fbjs/lib/invariant';\r\nimport { ConnectionInterface, ReaderFragment } from 'relay-runtime';\r\nimport { getValueAtPath } from './getValueAtPath';\r\n\r\nexport function getStateFromConnection(\r\n    direction: string,\r\n    fragmentNode: ReaderFragment,\r\n    connection: any | null,\r\n): {\r\n    cursor: string | null;\r\n    hasMore: boolean;\r\n} {\r\n    if (connection == null) {\r\n        return { cursor: null, hasMore: false };\r\n    }\r\n    const {\r\n        EDGES,\r\n        PAGE_INFO,\r\n        HAS_NEXT_PAGE,\r\n        HAS_PREV_PAGE,\r\n        END_CURSOR,\r\n        START_CURSOR,\r\n    } = ConnectionInterface.get();\r\n\r\n    invariant(\r\n        typeof connection === 'object',\r\n        'Relay: Expected connection in fragment `%s` to have been `null`, or ' +\r\n            'a plain object with %s and %s properties. Instead got `%s`.',\r\n        fragmentNode.name,\r\n        EDGES,\r\n        PAGE_INFO,\r\n        connection,\r\n    );\r\n\r\n    const edges = connection[EDGES];\r\n    const pageInfo = connection[PAGE_INFO];\r\n    if (edges == null || pageInfo == null) {\r\n        return { cursor: null, hasMore: false };\r\n    }\r\n\r\n    invariant(\r\n        Array.isArray(edges),\r\n        'Relay: Expected connection in fragment `%s` to have a plural `%s` field. ' +\r\n            'Instead got `%s`.',\r\n        fragmentNode.name,\r\n        EDGES,\r\n        edges,\r\n    );\r\n    invariant(\r\n        typeof pageInfo === 'object',\r\n        'Relay: Expected connection in fragment `%s` to have a `%s` field. ' + 'Instead got `%s`.',\r\n        fragmentNode.name,\r\n        PAGE_INFO,\r\n        pageInfo,\r\n    );\r\n\r\n    const cursor =\r\n        direction === 'forward' ? pageInfo[END_CURSOR] ?? null : pageInfo[START_CURSOR] ?? null;\r\n    invariant(\r\n        cursor === null || typeof cursor === 'string',\r\n        'Relay: Expected page info for connection in fragment `%s` to have a ' +\r\n            'valid `%s`. Instead got `%s`.',\r\n        fragmentNode.name,\r\n        START_CURSOR,\r\n        cursor,\r\n    );\r\n\r\n    let hasMore;\r\n    if (direction === 'forward') {\r\n        hasMore = cursor != null && pageInfo[HAS_NEXT_PAGE] === true;\r\n    } else {\r\n        hasMore = cursor != null && pageInfo[HAS_PREV_PAGE] === true;\r\n    }\r\n\r\n    return { cursor, hasMore };\r\n}\r\n\r\nexport function getConnectionState(\r\n    direction: string,\r\n    fragmentNode: ReaderFragment,\r\n    fragmentData: any,\r\n    connectionPathInFragmentData: ReadonlyArray<string | number>,\r\n): {\r\n    cursor: string | null;\r\n    hasMore: boolean;\r\n} {\r\n    const connection = getValueAtPath(fragmentData, connectionPathInFragmentData);\r\n    return getStateFromConnection(direction, fragmentNode, connection);\r\n}\r\n","/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @emails oncall+relay\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\n// flowlint ambiguous-object-type:error\r\n\r\n'use strict';\r\n\r\nimport * as invariant from 'fbjs/lib/invariant';\r\n\r\nimport { ConcreteRequest, ReaderFragment, ReaderRefetchMetadata } from 'relay-runtime';\r\n\r\nexport function getRefetchMetadata(\r\n    fragmentNode: ReaderFragment,\r\n    componentDisplayName: string,\r\n): {\r\n    fragmentRefPathInResponse: ReadonlyArray<string | number>;\r\n    identifierField: string | null;\r\n    refetchableRequest: ConcreteRequest;\r\n    refetchMetadata: ReaderRefetchMetadata;\r\n} {\r\n    invariant(\r\n        fragmentNode.metadata?.plural !== true,\r\n        'Relay: getRefetchMetadata(): Expected fragment `%s` not to be plural when using ' +\r\n            '`%s`. Remove `@relay(plural: true)` from fragment `%s` ' +\r\n            'in order to use it with `%s`.',\r\n        fragmentNode.name,\r\n        componentDisplayName,\r\n        fragmentNode.name,\r\n        componentDisplayName,\r\n    );\r\n\r\n    const refetchMetadata = fragmentNode.metadata?.refetch;\r\n    invariant(\r\n        refetchMetadata != null,\r\n        'Relay: getRefetchMetadata(): Expected fragment `%s` to be refetchable when using `%s`. ' +\r\n            'Did you forget to add a @refetchable directive to the fragment?',\r\n        componentDisplayName,\r\n        fragmentNode.name,\r\n    );\r\n\r\n    // handle both commonjs and es modules\r\n    const refetchableRequest: ConcreteRequest = (refetchMetadata as any).operation.default\r\n        ? (refetchMetadata as any).operation.default\r\n        : refetchMetadata.operation;\r\n    const fragmentRefPathInResponse = refetchMetadata.fragmentPathInResult;\r\n    invariant(\r\n        typeof refetchableRequest !== 'string',\r\n        'Relay: getRefetchMetadata(): Expected refetch query to be an ' +\r\n            \"operation and not a string when using `%s`. If you're seeing this, \" +\r\n            'this is likely a bug in Relay.',\r\n        componentDisplayName,\r\n    );\r\n    const identifierField = refetchMetadata.identifierField;\r\n    invariant(\r\n        identifierField == null || typeof identifierField === 'string',\r\n        'Relay: getRefetchMetadata(): Expected `identifierField` to be a string.',\r\n    );\r\n    return {\r\n        fragmentRefPathInResponse,\r\n        identifierField,\r\n        refetchableRequest,\r\n        refetchMetadata,\r\n    };\r\n}\r\n","/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @emails oncall+relay\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\n// flowlint ambiguous-object-type:error\r\n\r\n'use strict';\r\n\r\nimport * as invariant from 'fbjs/lib/invariant';\r\n\r\nimport { ConcreteRequest, ReaderFragment, ReaderPaginationMetadata } from 'relay-runtime';\r\nimport { getRefetchMetadata } from './getRefetchMetadata';\r\n\r\nexport function getPaginationMetadata(\r\n    fragmentNode: ReaderFragment,\r\n    componentDisplayName: string,\r\n): {\r\n    connectionPathInFragmentData: ReadonlyArray<string | number>;\r\n    identifierField: string | null;\r\n    paginationRequest: ConcreteRequest;\r\n    paginationMetadata: ReaderPaginationMetadata;\r\n    stream: boolean;\r\n} {\r\n    const { refetchableRequest: paginationRequest, refetchMetadata } = getRefetchMetadata(\r\n        fragmentNode,\r\n        componentDisplayName,\r\n    );\r\n\r\n    const paginationMetadata = refetchMetadata.connection;\r\n    invariant(\r\n        paginationMetadata != null,\r\n        'Relay: getPaginationMetadata(): Expected fragment `%s` to include a ' +\r\n            'connection when using `%s`. Did you forget to add a @connection ' +\r\n            'directive to the connection field in the fragment?',\r\n        componentDisplayName,\r\n        fragmentNode.name,\r\n    );\r\n    const connectionPathInFragmentData = paginationMetadata.path;\r\n\r\n    const connectionMetadata = (fragmentNode.metadata?.connection ?? [])[0];\r\n    invariant(\r\n        connectionMetadata != null,\r\n        'Relay: getPaginationMetadata(): Expected fragment `%s` to include a ' +\r\n            'connection when using `%s`. Did you forget to add a @connection ' +\r\n            'directive to the connection field in the fragment?',\r\n        componentDisplayName,\r\n        fragmentNode.name,\r\n    );\r\n    const identifierField = refetchMetadata.identifierField;\r\n    invariant(\r\n        identifierField == null || typeof identifierField === 'string',\r\n        'Relay: getRefetchMetadata(): Expected `identifierField` to be a string.',\r\n    );\r\n    return {\r\n        connectionPathInFragmentData,\r\n        identifierField,\r\n        paginationRequest,\r\n        paginationMetadata,\r\n        stream: connectionMetadata.stream === true,\r\n    };\r\n}\r\n","import * as areEqual from 'fbjs/lib/areEqual';\r\nimport * as invariant from 'fbjs/lib/invariant';\r\nimport * as warning from 'fbjs/lib/warning';\r\nimport {\r\n    __internal,\r\n    getSelector,\r\n    IEnvironment,\r\n    Disposable,\r\n    Snapshot,\r\n    Variables,\r\n    getVariablesFromFragment,\r\n    OperationDescriptor,\r\n    getFragmentIdentifier,\r\n    PluralReaderSelector,\r\n    ReaderSelector,\r\n    SingularReaderSelector,\r\n    ReaderFragment,\r\n    getDataIDsFromFragment,\r\n    RequestDescriptor,\r\n} from 'relay-runtime';\r\nimport { Fetcher, fetchResolver } from './FetchResolver';\r\nimport { getConnectionState, getStateFromConnection } from './getConnectionState';\r\nimport { getPaginationMetadata } from './getPaginationMetadata';\r\nimport { getPaginationVariables } from './getPaginationVariables';\r\nimport { getRefetchMetadata } from './getRefetchMetadata';\r\nimport { getValueAtPath } from './getValueAtPath';\r\nimport {\r\n    FragmentNames,\r\n    Options,\r\n    OptionsLoadMore,\r\n    PAGINATION_NAME,\r\n    REFETCHABLE_NAME,\r\n} from './RelayHooksTypes';\r\nimport { createOperation, forceCache } from './Utils';\r\nconst { getPromiseForActiveRequest } = __internal;\r\n\r\ntype SingularOrPluralSnapshot = Snapshot | Array<Snapshot>;\r\n\r\nfunction lookupFragment(environment, selector): SingularOrPluralSnapshot {\r\n    return selector.kind === 'PluralReaderSelector'\r\n        ? selector.selectors.map((s) => environment.lookup(s))\r\n        : environment.lookup(selector);\r\n}\r\n\r\nfunction getFragmentResult(snapshot: SingularOrPluralSnapshot): any {\r\n    const missData = isMissingData(snapshot);\r\n    if (Array.isArray(snapshot)) {\r\n        return { snapshot, data: snapshot.map((s) => s.data), isMissingData: missData };\r\n    }\r\n    return { snapshot, data: snapshot.data, isMissingData: missData };\r\n}\r\n\r\ntype FragmentResult = {\r\n    snapshot?: SingularOrPluralSnapshot | null;\r\n    data: any;\r\n    isMissingData?: boolean;\r\n    owner?: any;\r\n};\r\n\r\nfunction isMissingData(snapshot: SingularOrPluralSnapshot): boolean {\r\n    if (Array.isArray(snapshot)) {\r\n        return snapshot.some((s) => s.isMissingData);\r\n    }\r\n    return snapshot.isMissingData;\r\n}\r\n\r\nfunction getPromiseForPendingOperationAffectingOwner(\r\n    environment: IEnvironment,\r\n    request: RequestDescriptor,\r\n): Promise<void> | null {\r\n    return environment.getOperationTracker().getPromiseForPendingOperationsAffectingOwner(request);\r\n}\r\n\r\nfunction _getAndSavePromiseForFragmentRequestInFlight(\r\n    fragmentOwner: RequestDescriptor,\r\n    environment: IEnvironment,\r\n): Promise<void> | null {\r\n    const networkPromise =\r\n        getPromiseForActiveRequest(environment, fragmentOwner) ??\r\n        getPromiseForPendingOperationAffectingOwner(environment, fragmentOwner);\r\n\r\n    if (!networkPromise) {\r\n        return null;\r\n    }\r\n    return networkPromise;\r\n}\r\n\r\nexport class FragmentResolver {\r\n    _environment: IEnvironment;\r\n    _fragment: ReaderFragment;\r\n    _fragmentRef: any;\r\n    _fragmentRefRefetch: any;\r\n    _idfragment: any;\r\n    _idfragmentrefetch: any;\r\n    resolverData: FragmentResult;\r\n    _disposable: Disposable;\r\n    _selector: ReaderSelector;\r\n    refreshHooks: any;\r\n    fetcherRefecth: Fetcher;\r\n    fetcherNext: Fetcher;\r\n    fetcherPrevious: Fetcher;\r\n    unmounted = false;\r\n    name: string;\r\n    refetchable = false;\r\n    pagination = false;\r\n    result: any;\r\n\r\n    constructor(name: FragmentNames) {\r\n        this.name = name;\r\n        this.pagination = name === PAGINATION_NAME;\r\n        this.refetchable = name === REFETCHABLE_NAME || this.pagination;\r\n\r\n        const setLoading = (_loading): void => this.refreshHooks();\r\n        if (this.refetchable) {\r\n            this.fetcherRefecth = fetchResolver({\r\n                setLoading,\r\n                doRetain: true,\r\n            });\r\n        }\r\n        if (this.pagination) {\r\n            this.fetcherNext = fetchResolver({ setLoading });\r\n            this.fetcherPrevious = fetchResolver({ setLoading });\r\n        }\r\n    }\r\n\r\n    setForceUpdate(forceUpdate: () => void): void {\r\n        this.refreshHooks = (): void => {\r\n            this.resolveResult();\r\n            forceUpdate();\r\n        };\r\n    }\r\n\r\n    setUnmounted(): void {\r\n        this.unmounted = true;\r\n    }\r\n\r\n    isEqualsFragmentRef(prevFragment, fragmentRef): boolean {\r\n        if (this._fragmentRef !== fragmentRef) {\r\n            const prevIDs = getDataIDsFromFragment(this._fragment, prevFragment);\r\n            const nextIDs = getDataIDsFromFragment(this._fragment, fragmentRef);\r\n            if (\r\n                !areEqual(prevIDs, nextIDs) ||\r\n                !areEqual(\r\n                    this.getFragmentVariables(fragmentRef),\r\n                    this.getFragmentVariables(prevFragment),\r\n                )\r\n            ) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    dispose(): void {\r\n        this.unsubscribe();\r\n        this.fetcherNext && this.fetcherNext.dispose();\r\n        this.fetcherPrevious && this.fetcherPrevious.dispose();\r\n        this._idfragmentrefetch = null;\r\n        this._fragmentRefRefetch = null;\r\n        this.fetcherRefecth && this.fetcherRefecth.dispose();\r\n    }\r\n\r\n    getFragmentVariables(fRef = this._fragmentRef): Variables {\r\n        return getVariablesFromFragment(this._fragment, fRef);\r\n    }\r\n\r\n    resolve(\r\n        environment: IEnvironment,\r\n        idfragment: string,\r\n        fragment: ReaderFragment,\r\n        fragmentRef,\r\n    ): void {\r\n        if (\r\n            !this.resolverData ||\r\n            this._environment !== environment ||\r\n            (idfragment !== this._idfragment &&\r\n                (!this._idfragmentrefetch ||\r\n                    (this._idfragmentrefetch && idfragment !== this._idfragmentrefetch)))\r\n        ) {\r\n            this._fragment = fragment;\r\n            this._fragmentRef = fragmentRef;\r\n            this._idfragment = idfragment;\r\n            this._selector = null;\r\n            this.dispose();\r\n            this._environment = environment;\r\n            this.lookup(fragment, this._fragmentRef);\r\n            this.resolveResult();\r\n        }\r\n    }\r\n\r\n    lookup(fragment, fragmentRef): void {\r\n        if (fragmentRef == null) {\r\n            this.resolverData = { data: null };\r\n            return;\r\n        }\r\n        const isPlural =\r\n            fragment.metadata && fragment.metadata.plural && fragment.metadata.plural === true;\r\n        if (isPlural) {\r\n            if (fragmentRef.length === 0) {\r\n                this.resolverData = { data: [] };\r\n                return;\r\n            }\r\n        }\r\n        this._selector = getSelector(fragment, fragmentRef);\r\n        const snapshot = lookupFragment(this._environment, this._selector);\r\n\r\n        this.resolverData = getFragmentResult(snapshot);\r\n        const owner = this._selector\r\n            ? this._selector.kind === 'PluralReaderSelector'\r\n                ? (this._selector as any).selectors[0].owner\r\n                : (this._selector as any).owner\r\n            : null;\r\n        this.resolverData.owner = owner;\r\n        //this.subscribe();\r\n    }\r\n\r\n    checkAndSuspense(suspense): void {\r\n        if (suspense && this.resolverData.isMissingData && this.resolverData.owner) {\r\n            const fragmentOwner = this.resolverData.owner;\r\n            const networkPromise = _getAndSavePromiseForFragmentRequestInFlight(\r\n                fragmentOwner,\r\n                this._environment,\r\n            );\r\n            const parentQueryName = fragmentOwner.node.params.name ?? 'Unknown Parent Query';\r\n            if (networkPromise != null) {\r\n                // When the Promise for the request resolves, we need to make sure to\r\n                // update the cache with the latest data available in the store before\r\n                // resolving the Promise\r\n                const promise = networkPromise\r\n                    .then(() => {\r\n                        if (this._idfragmentrefetch) {\r\n                            this.resolveResult();\r\n                        } else {\r\n                            this._idfragment = null;\r\n                            this.dispose();\r\n                        }\r\n                        //;\r\n                    })\r\n                    .catch((_error: Error) => {\r\n                        if (this._idfragmentrefetch) {\r\n                            this.resolveResult();\r\n                        } else {\r\n                            this._idfragment = null;\r\n                            this.dispose();\r\n                        }\r\n                    });\r\n\r\n                // $FlowExpectedError[prop-missing] Expando to annotate Promises.\r\n                (promise as any).displayName = 'Relay(' + parentQueryName + ')';\r\n                this.unsubscribe();\r\n                this.refreshHooks = (): void => undefined;\r\n                throw promise;\r\n            }\r\n            warning(\r\n                false,\r\n                'Relay: Tried reading fragment `%s` declared in ' +\r\n                    '`%s`, but it has missing data and its parent query `%s` is not ' +\r\n                    'being fetched.\\n' +\r\n                    'This might be fixed by by re-running the Relay Compiler. ' +\r\n                    ' Otherwise, make sure of the following:\\n' +\r\n                    '* You are correctly fetching `%s` if you are using a ' +\r\n                    '\"store-only\" `fetchPolicy`.\\n' +\r\n                    \"* Other queries aren't accidentally fetching and overwriting \" +\r\n                    'the data for this fragment.\\n' +\r\n                    '* Any related mutations or subscriptions are fetching all of ' +\r\n                    'the data for this fragment.\\n' +\r\n                    \"* Any related store updaters aren't accidentally deleting \" +\r\n                    'data for this fragment.',\r\n                this._fragment.name,\r\n                this.name,\r\n                parentQueryName,\r\n                parentQueryName,\r\n            );\r\n        }\r\n        this.fetcherRefecth && this.fetcherRefecth.checkAndSuspense(suspense);\r\n    }\r\n\r\n    getData(): any | null {\r\n        return this.result;\r\n    }\r\n\r\n    resolveResult(): any {\r\n        const { data } = this.resolverData;\r\n        if (this.refetchable || this.pagination) {\r\n            const { isLoading, error } = this.fetcherRefecth.getData();\r\n            const refetch = this.refetch;\r\n            if (!this.pagination) {\r\n                if ('production' !== process.env.NODE_ENV) {\r\n                    getRefetchMetadata(this._fragment, this.name);\r\n                }\r\n                this.result = {\r\n                    data,\r\n                    isLoading,\r\n                    error,\r\n                    refetch,\r\n                };\r\n                return;\r\n            }\r\n            const { connectionPathInFragmentData } = getPaginationMetadata(\r\n                this._fragment,\r\n                this.name,\r\n            );\r\n\r\n            const connection = getValueAtPath(data, connectionPathInFragmentData);\r\n            const { hasMore: hasNext } = getStateFromConnection(\r\n                'forward',\r\n                this._fragment,\r\n                connection,\r\n            );\r\n            const { hasMore: hasPrevious } = getStateFromConnection(\r\n                'backward',\r\n                this._fragment,\r\n                connection,\r\n            );\r\n            const { isLoading: isLoadingNext, error: errorNext } = this.fetcherNext.getData();\r\n            const {\r\n                isLoading: isLoadingPrevious,\r\n                error: errorPrevious,\r\n            } = this.fetcherPrevious.getData();\r\n            this.result = {\r\n                data,\r\n                hasNext,\r\n                isLoadingNext,\r\n                hasPrevious,\r\n                isLoadingPrevious,\r\n                isLoading,\r\n                errorNext,\r\n                errorPrevious,\r\n                error,\r\n                refetch,\r\n                loadNext: this.loadNext,\r\n                loadPrevious: this.loadPrevious,\r\n            };\r\n            return;\r\n        }\r\n        this.result = data;\r\n    }\r\n\r\n    unsubscribe(): void {\r\n        this._disposable && this._disposable.dispose();\r\n    }\r\n\r\n    subscribe(): void {\r\n        const environment = this._environment;\r\n        const renderedSnapshot = this.resolverData.snapshot;\r\n        this.unsubscribe();\r\n        const dataSubscriptions = [];\r\n        if (renderedSnapshot) {\r\n            if (Array.isArray(renderedSnapshot)) {\r\n                renderedSnapshot.forEach((snapshot, idx) => {\r\n                    dataSubscriptions.push(\r\n                        environment.subscribe(snapshot, (latestSnapshot) => {\r\n                            this.resolverData.snapshot[idx] = latestSnapshot;\r\n                            this.resolverData.data[idx] = latestSnapshot.data;\r\n                            this.resolverData.isMissingData = false;\r\n                            this.refreshHooks();\r\n                        }),\r\n                    );\r\n                });\r\n            } else {\r\n                dataSubscriptions.push(\r\n                    environment.subscribe(renderedSnapshot, (latestSnapshot) => {\r\n                        this.resolverData = getFragmentResult(latestSnapshot);\r\n                        this.resolverData.isMissingData = false;\r\n                        this.refreshHooks();\r\n                    }),\r\n                );\r\n            }\r\n        }\r\n\r\n        this._disposable = {\r\n            dispose: (): void => {\r\n                dataSubscriptions.map((s) => s.dispose());\r\n                this._disposable = undefined;\r\n            },\r\n        };\r\n    }\r\n\r\n    refetch = (variables: Variables, options?: Options): Disposable => {\r\n        if (this.unmounted === true) {\r\n            warning(\r\n                false,\r\n                'Relay: Unexpected call to `refetch` on unmounted component for fragment ' +\r\n                    '`%s` in `%s`. It looks like some instances of your component are ' +\r\n                    'still trying to fetch data but they already unmounted. ' +\r\n                    'Please make sure you clear all timers, intervals, ' +\r\n                    'async calls, etc that may trigger a fetch.',\r\n                this._fragment.name,\r\n                this.name,\r\n            );\r\n            return { dispose: (): void => {} };\r\n        }\r\n        if (this._selector == null) {\r\n            warning(\r\n                false,\r\n                'Relay: Unexpected call to `refetch` while using a null fragment ref ' +\r\n                    'for fragment `%s` in `%s`. When calling `refetch`, we expect ' +\r\n                    \"initial fragment data to be non-null. Please make sure you're \" +\r\n                    'passing a valid fragment ref to `%s` before calling ' +\r\n                    '`refetch`, or make sure you pass all required variables to `refetch`.',\r\n                this._fragment.name,\r\n                this.name,\r\n                this.name,\r\n            );\r\n        }\r\n\r\n        const {\r\n            fragmentRefPathInResponse,\r\n            identifierField,\r\n            refetchableRequest,\r\n        } = getRefetchMetadata(this._fragment, this.name);\r\n        const fragmentData = this.getData().data;\r\n        const identifierValue =\r\n            identifierField != null && fragmentData != null && typeof fragmentData === 'object'\r\n                ? fragmentData[identifierField]\r\n                : null;\r\n\r\n        let parentVariables;\r\n        let fragmentVariables;\r\n        if (this._selector == null) {\r\n            parentVariables = {};\r\n            fragmentVariables = {};\r\n        } else if (this._selector.kind === 'PluralReaderSelector') {\r\n            parentVariables =\r\n                (this._selector as PluralReaderSelector).selectors[0]?.owner.variables ?? {};\r\n            fragmentVariables =\r\n                (this._selector as PluralReaderSelector).selectors[0]?.variables ?? {};\r\n        } else {\r\n            parentVariables = (this._selector as SingularReaderSelector).owner.variables;\r\n            fragmentVariables = (this._selector as SingularReaderSelector).variables;\r\n        }\r\n\r\n        // NOTE: A user of `useRefetchableFragment()` may pass a subset of\r\n        // all variables required by the fragment when calling `refetch()`.\r\n        // We fill in any variables not passed by the call to `refetch()` with the\r\n        // variables from the original parent fragment owner.\r\n        /* $FlowFixMe[cannot-spread-indexer] (>=0.123.0) This comment suppresses\r\n         * an error found when Flow v0.123.0 was deployed. To see the error\r\n         * delete this comment and run Flow. */\r\n        const refetchVariables = {\r\n            ...parentVariables,\r\n            /* $FlowFixMe[exponential-spread] (>=0.111.0) This comment suppresses\r\n             * an error found when Flow v0.111.0 was deployed. To see the error,\r\n             * delete this comment and run Flow. */\r\n            ...fragmentVariables,\r\n            ...variables,\r\n        };\r\n\r\n        if (identifierField != null && !variables.hasOwnProperty('id')) {\r\n            // @refetchable fragments are guaranteed to have an `id` selection\r\n            // if the type is Node, implements Node, or is @fetchable. Double-check\r\n            // that there actually is a value at runtime.\r\n            if (typeof identifierValue !== 'string') {\r\n                warning(\r\n                    false,\r\n                    'Relay: Expected result to have a string  ' +\r\n                        '`%s` in order to refetch, got `%s`.',\r\n                    identifierField,\r\n                    identifierValue,\r\n                );\r\n            }\r\n            refetchVariables.id = identifierValue;\r\n        }\r\n\r\n        const onNext = (operation: OperationDescriptor, snapshot: Snapshot): void => {\r\n            const fragmentRef = getValueAtPath(snapshot.data, fragmentRefPathInResponse);\r\n            const isEquals = this.isEqualsFragmentRef(\r\n                this._fragmentRefRefetch || this._fragmentRef,\r\n                fragmentRef,\r\n            );\r\n            const missData = isMissingData(snapshot); //fromStore && isMissingData(snapshot);\r\n            if (!isEquals || missData) {\r\n                this._fragmentRefRefetch = fragmentRef;\r\n                this._idfragmentrefetch = getFragmentIdentifier(this._fragment, fragmentRef);\r\n                this.lookup(this._fragment, fragmentRef);\r\n                this.subscribe();\r\n                /*if (!missData) {\r\n                    this.subscribe();\r\n                }*/\r\n                this.resolverData.isMissingData = missData;\r\n                this.resolverData.owner = operation.request;\r\n                this.refreshHooks();\r\n            }\r\n        };\r\n        if (this.pagination) {\r\n            this.fetcherNext.dispose();\r\n            this.fetcherPrevious.dispose();\r\n        }\r\n        const operation = createOperation(refetchableRequest, refetchVariables, forceCache);\r\n        return this.fetcherRefecth.fetch(\r\n            this._environment,\r\n            operation,\r\n            options?.fetchPolicy,\r\n            options?.onComplete,\r\n            onNext,\r\n            options?.UNSTABLE_renderPolicy,\r\n        );\r\n    };\r\n\r\n    loadPrevious = (count: number, options?: OptionsLoadMore): Disposable => {\r\n        return this.loadMore('backward', count, options);\r\n    };\r\n\r\n    loadNext = (count: number, options?: OptionsLoadMore): Disposable => {\r\n        return this.loadMore('forward', count, options);\r\n    };\r\n\r\n    loadMore = (\r\n        direction: 'backward' | 'forward',\r\n        count: number,\r\n        options?: OptionsLoadMore,\r\n    ): Disposable => {\r\n        const onComplete = options?.onComplete ?? ((): void => undefined);\r\n\r\n        const fragmentData = this.getData().data;\r\n\r\n        const fetcher = direction === 'backward' ? this.fetcherPrevious : this.fetcherNext;\r\n        if (this.unmounted === true) {\r\n            // Bail out and warn if we're trying to paginate after the component\r\n            // has unmounted\r\n            warning(\r\n                false,\r\n                'Relay: Unexpected fetch on unmounted component for fragment ' +\r\n                    '`%s` in `%s`. It looks like some instances of your component are ' +\r\n                    'still trying to fetch data but they already unmounted. ' +\r\n                    'Please make sure you clear all timers, intervals, ' +\r\n                    'async calls, etc that may trigger a fetch.',\r\n                this._fragment.name,\r\n                this.name,\r\n            );\r\n            return { dispose: (): void => {} };\r\n        }\r\n        if (this._selector == null) {\r\n            warning(\r\n                false,\r\n                'Relay: Unexpected fetch while using a null fragment ref ' +\r\n                    'for fragment `%s` in `%s`. When fetching more items, we expect ' +\r\n                    \"initial fragment data to be non-null. Please make sure you're \" +\r\n                    'passing a valid fragment ref to `%s` before paginating.',\r\n                this._fragment.name,\r\n                this.name,\r\n                this.name,\r\n            );\r\n            onComplete(null);\r\n            return { dispose: (): void => {} };\r\n        }\r\n        const isRequestActive = (this._environment as any).isRequestActive(\r\n            (this._selector as SingularReaderSelector).owner.identifier,\r\n        );\r\n        if (isRequestActive || fetcher.getData().isLoading === true || fragmentData == null) {\r\n            onComplete(null);\r\n            return { dispose: (): void => {} };\r\n        }\r\n        invariant(\r\n            this._selector != null && this._selector.kind !== 'PluralReaderSelector',\r\n            'Relay: Expected to be able to find a non-plural fragment owner for ' +\r\n                \"fragment `%s` when using `%s`. If you're seeing this, \" +\r\n                'this is likely a bug in Relay.',\r\n            this._fragment.name,\r\n            this.name,\r\n        );\r\n\r\n        const {\r\n            paginationRequest,\r\n            paginationMetadata,\r\n            identifierField,\r\n            connectionPathInFragmentData,\r\n        } = getPaginationMetadata(this._fragment, this.name);\r\n        const identifierValue =\r\n            identifierField != null && fragmentData != null && typeof fragmentData === 'object'\r\n                ? fragmentData[identifierField]\r\n                : null;\r\n\r\n        const parentVariables = (this._selector as SingularReaderSelector).owner.variables;\r\n        const fragmentVariables = (this._selector as SingularReaderSelector).variables;\r\n        const extraVariables = options?.UNSTABLE_extraVariables;\r\n        const baseVariables = {\r\n            ...parentVariables,\r\n            ...fragmentVariables,\r\n        };\r\n        const { cursor } = getConnectionState(\r\n            direction,\r\n            this._fragment,\r\n            fragmentData,\r\n            connectionPathInFragmentData,\r\n        );\r\n        const paginationVariables = getPaginationVariables(\r\n            direction,\r\n            count,\r\n            cursor,\r\n            baseVariables,\r\n            { ...extraVariables },\r\n            paginationMetadata,\r\n        );\r\n\r\n        // If the query needs an identifier value ('id' or similar) and one\r\n        // was not explicitly provided, read it from the fragment data.\r\n        if (identifierField != null) {\r\n            // @refetchable fragments are guaranteed to have an `id` selection\r\n            // if the type is Node, implements Node, or is @fetchable. Double-check\r\n            // that there actually is a value at runtime.\r\n            if (typeof identifierValue !== 'string') {\r\n                warning(\r\n                    false,\r\n                    'Relay: Expected result to have a string  ' +\r\n                        '`%s` in order to refetch, got `%s`.',\r\n                    identifierField,\r\n                    identifierValue,\r\n                );\r\n            }\r\n            paginationVariables.id = identifierValue;\r\n        }\r\n\r\n        const onNext = (): void => {};\r\n\r\n        const operation = createOperation(paginationRequest, paginationVariables, forceCache);\r\n        return fetcher.fetch(\r\n            this._environment,\r\n            operation,\r\n            undefined, //options?.fetchPolicy,\r\n            onComplete,\r\n            onNext,\r\n        );\r\n    };\r\n}\r\n","/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @emails oncall+relay\r\n * @flow strict-local\r\n * @format\r\n */\r\n\r\n// flowlint ambiguous-object-type:error\r\n\r\n'use strict';\r\n\r\nimport * as invariant from 'fbjs/lib/invariant';\r\nimport * as warning from 'fbjs/lib/warning';\r\n\r\nimport { ReaderPaginationMetadata, Variables } from 'relay-runtime';\r\n\r\nexport function getPaginationVariables(\r\n    direction: 'forward' | 'backward',\r\n    count: number,\r\n    cursor: string | null,\r\n    baseVariables: Variables,\r\n    extraVariables: Variables,\r\n    paginationMetadata: ReaderPaginationMetadata,\r\n): { [key: string]: any } {\r\n    const { backward: backwardMetadata, forward: forwardMetadata } = paginationMetadata;\r\n\r\n    if (direction === 'backward') {\r\n        invariant(\r\n            backwardMetadata != null &&\r\n                backwardMetadata.count != null &&\r\n                backwardMetadata.cursor != null,\r\n            'Relay: Expected backward pagination metadata to be available. ' +\r\n                \"If you're seeing this, this is likely a bug in Relay.\",\r\n        );\r\n        warning(\r\n            !extraVariables.hasOwnProperty(backwardMetadata.cursor),\r\n            'Relay: `UNSTABLE_extraVariables` provided by caller should not ' +\r\n                'contain cursor variable `%s`. This variable is automatically ' +\r\n                'determined by Relay.',\r\n            backwardMetadata.cursor,\r\n        );\r\n        warning(\r\n            !extraVariables.hasOwnProperty(backwardMetadata.count),\r\n            'Relay: `UNSTABLE_extraVariables` provided by caller should not ' +\r\n                'contain count variable `%s`. This variable is automatically ' +\r\n                'determined by Relay.',\r\n            backwardMetadata.count,\r\n        );\r\n        const paginationVariables = {\r\n            ...baseVariables,\r\n            ...extraVariables,\r\n            [backwardMetadata.cursor]: cursor,\r\n            [backwardMetadata.count]: count,\r\n        };\r\n        if (forwardMetadata && forwardMetadata.cursor) {\r\n            paginationVariables[forwardMetadata.cursor] = null;\r\n        }\r\n        if (forwardMetadata && forwardMetadata.count) {\r\n            paginationVariables[forwardMetadata.count] = null;\r\n        }\r\n        return paginationVariables;\r\n    }\r\n\r\n    invariant(\r\n        forwardMetadata != null && forwardMetadata.count != null && forwardMetadata.cursor != null,\r\n        'Relay: Expected forward pagination metadata to be available. ' +\r\n            \"If you're seeing this, this is likely a bug in Relay.\",\r\n    );\r\n    warning(\r\n        !extraVariables.hasOwnProperty(forwardMetadata.cursor),\r\n        'Relay: `UNSTABLE_extraVariables` provided by caller should not ' +\r\n            'contain cursor variable `%s`. This variable is automatically ' +\r\n            'determined by Relay.',\r\n        forwardMetadata.cursor,\r\n    );\r\n    warning(\r\n        !extraVariables.hasOwnProperty(forwardMetadata.count),\r\n        'Relay: `UNSTABLE_extraVariables` provided by caller should not ' +\r\n            'contain count variable `%s`. This variable is automatically ' +\r\n            'determined by Relay.',\r\n        forwardMetadata.count,\r\n    );\r\n    const paginationVariables = {\r\n        ...baseVariables,\r\n        ...extraVariables,\r\n        [forwardMetadata.cursor]: cursor,\r\n        [forwardMetadata.count]: count,\r\n    };\r\n    if (backwardMetadata && backwardMetadata.cursor) {\r\n        paginationVariables[backwardMetadata.cursor] = null;\r\n    }\r\n    if (backwardMetadata && backwardMetadata.count) {\r\n        paginationVariables[backwardMetadata.count] = null;\r\n    }\r\n    return paginationVariables;\r\n}\r\n","import * as warning from 'fbjs/lib/warning';\r\nimport { useEffect, useRef, useMemo } from 'react';\r\nimport { GraphQLTaggedNode, getFragmentIdentifier, getFragment } from 'relay-runtime';\r\nimport { FragmentResolver } from './FragmentResolver';\r\nimport { FragmentNames } from './RelayHooksTypes';\r\nimport { useForceUpdate } from './useForceUpdate';\r\nimport { useRelayEnvironment } from './useRelayEnvironment';\r\n\r\nexport function useOssFragment(\r\n    fragmentNode: GraphQLTaggedNode,\r\n    fragmentRef: any | null,\r\n    suspense: boolean,\r\n    name: FragmentNames,\r\n): any {\r\n    const environment = useRelayEnvironment();\r\n    const forceUpdate = useForceUpdate();\r\n    const ref = useRef<{ resolver: FragmentResolver }>(null);\r\n    if (ref.current === null || ref.current === undefined) {\r\n        ref.current = {\r\n            resolver: new FragmentResolver(name),\r\n        };\r\n    }\r\n\r\n    const { resolver } = ref.current;\r\n\r\n    useEffect(() => {\r\n        return (): void => {\r\n            ref.current.resolver.setUnmounted();\r\n        };\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        return (): void => {\r\n            resolver.dispose();\r\n        };\r\n    }, [resolver]);\r\n\r\n    const fragment = useMemo(() => {\r\n        return getFragment(fragmentNode);\r\n    }, [fragmentNode]);\r\n\r\n    const idfragment = useMemo(() => {\r\n        return getFragmentIdentifier(fragment, fragmentRef);\r\n    }, [fragment, fragmentRef]);\r\n\r\n    useEffect(() => {\r\n        resolver.subscribe();\r\n        return (): void => {\r\n            resolver.unsubscribe();\r\n        };\r\n    }, [resolver, idfragment, environment]);\r\n\r\n    resolver.resolve(environment, idfragment, fragment, fragmentRef);\r\n\r\n    resolver.checkAndSuspense(suspense);\r\n    resolver.setForceUpdate(forceUpdate);\r\n\r\n    const data = resolver.getData();\r\n\r\n    if ('production' !== process.env.NODE_ENV) {\r\n        if (\r\n            fragmentRef != null &&\r\n            (data === undefined ||\r\n                (Array.isArray(data) &&\r\n                    data.length > 0 &&\r\n                    data.every((data) => data === undefined)))\r\n        ) {\r\n            warning(\r\n                false,\r\n                'Relay: Expected to have been able to read non-null data for ' +\r\n                    'fragment `%s` declared in ' +\r\n                    '`%s`, since fragment reference was non-null. ' +\r\n                    \"Make sure that that `%s`'s parent isn't \" +\r\n                    'holding on to and/or passing a fragment reference for data that ' +\r\n                    'has been deleted.',\r\n                fragment,\r\n                name,\r\n                name,\r\n            );\r\n        }\r\n    }\r\n\r\n    return [data, resolver];\r\n}\r\n","import useMounted from '@restart/hooks/useMounted';\r\nimport * as invariant from 'fbjs/lib/invariant';\r\nimport * as React from 'react';\r\nimport { Environment, MutationParameters, commitMutation } from 'relay-runtime';\r\nimport {\r\n    MutationNode,\r\n    MutationConfig,\r\n    MutationConfigWithoutVariables,\r\n    MutationState,\r\n    Mutate,\r\n    MutateWithVariables,\r\n} from './RelayHooksTypes';\r\nimport { useRelayEnvironment } from './useRelayEnvironment';\r\n\r\nconst { useCallback, useState } = React;\r\n\r\nexport function useMutation<T extends MutationParameters>(\r\n    mutation: MutationNode<T>,\r\n    userConfig?: MutationConfigWithoutVariables<T>,\r\n    /** if not provided, the context environment will be used. */\r\n    environment?: Environment,\r\n): [MutateWithVariables<T>, MutationState<T>];\r\nexport function useMutation<T extends MutationParameters>(\r\n    mutation: MutationNode<T>,\r\n    userConfig?: MutationConfig<T>,\r\n    /** if not provided, the context environment will be used. */\r\n    environment?: Environment,\r\n): [Mutate<T>, MutationState<T>];\r\nexport function useMutation<T extends MutationParameters>(\r\n    mutation: MutationNode<T>,\r\n    userConfig: MutationConfig<T> = {},\r\n    /** if not provided, the context environment will be used. */\r\n    environment?: Environment,\r\n): [Mutate<T>, MutationState<T>] {\r\n    const [state, setState] = useState<MutationState<T>>({\r\n        loading: false,\r\n        data: null,\r\n        error: null,\r\n    });\r\n\r\n    const isMounted = useMounted();\r\n\r\n    const relayEnvironment = useRelayEnvironment();\r\n    const resolvedEnvironment = environment || relayEnvironment;\r\n    const {\r\n        configs,\r\n        variables,\r\n        uploadables,\r\n        onCompleted,\r\n        onError,\r\n        optimisticUpdater,\r\n        optimisticResponse,\r\n        updater,\r\n    } = userConfig;\r\n\r\n    const mutate: Mutate<T> = useCallback(\r\n        (config) => {\r\n            const mergedConfig = {\r\n                configs,\r\n                variables,\r\n                uploadables,\r\n                onCompleted,\r\n                onError,\r\n                optimisticUpdater,\r\n                optimisticResponse,\r\n                updater,\r\n                ...config,\r\n            };\r\n\r\n            invariant(mergedConfig.variables, 'you must specify variables');\r\n\r\n            if (isMounted()) {\r\n                setState({\r\n                    loading: true,\r\n                    data: mergedConfig.optimisticResponse,\r\n                    error: null,\r\n                });\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                function handleError(error: any): void {\r\n                    if (isMounted()) {\r\n                        setState({\r\n                            loading: false,\r\n                            data: null,\r\n                            error,\r\n                        });\r\n                    }\r\n\r\n                    if (mergedConfig.onError) {\r\n                        mergedConfig.onError(error);\r\n                        resolve(null);\r\n                    } else {\r\n                        reject(error);\r\n                    }\r\n                }\r\n\r\n                commitMutation(resolvedEnvironment, {\r\n                    ...mergedConfig,\r\n                    mutation,\r\n                    variables: mergedConfig.variables,\r\n                    onCompleted: (response, errors) => {\r\n                        if (errors) {\r\n                            // FIXME: This isn't right. onError expects a single error.\r\n                            handleError(errors);\r\n                            return;\r\n                        }\r\n\r\n                        if (isMounted()) {\r\n                            setState({\r\n                                loading: false,\r\n                                data: response,\r\n                                error: null,\r\n                            });\r\n                        }\r\n\r\n                        if (mergedConfig.onCompleted) {\r\n                            mergedConfig.onCompleted(response);\r\n                        }\r\n                        resolve(response);\r\n                    },\r\n                    onError: handleError,\r\n                });\r\n            });\r\n        },\r\n        [\r\n            resolvedEnvironment,\r\n            configs,\r\n            mutation,\r\n            variables,\r\n            uploadables,\r\n            onCompleted,\r\n            onError,\r\n            optimisticUpdater,\r\n            optimisticResponse,\r\n            updater,\r\n            isMounted,\r\n        ],\r\n    );\r\n\r\n    return [mutate, state];\r\n}\r\n","import * as React from 'react';\r\nimport { Environment } from 'relay-runtime';\r\nimport { ReactRelayContext } from './ReactRelayContext'; // eslint-disable-line @typescript-eslint/no-unused-vars\r\n\r\nexport const RelayEnvironmentProvider = function<\r\n    TEnvironment extends Environment = Environment\r\n>(props: { children: React.ReactNode; environment: TEnvironment }): JSX.Element {\r\n    const context = React.useMemo(() => ({ environment: props.environment }), [props.environment]);\r\n    return (\r\n        <ReactRelayContext.Provider value={context}>{props.children}</ReactRelayContext.Provider>\r\n    );\r\n};\r\n","import { GraphQLTaggedNode } from 'relay-runtime';\r\nimport {\r\n    KeyType,\r\n    KeyReturnType,\r\n    $Call,\r\n    ArrayKeyType,\r\n    ArrayKeyReturnType,\r\n    FRAGMENT_NAME,\r\n} from './RelayHooksTypes';\r\nimport { useOssFragment } from './useOssFragment';\r\n\r\nexport function useFragment<TKey extends KeyType>(\r\n    fragmentNode: GraphQLTaggedNode,\r\n    fragmentRef: TKey,\r\n): $Call<KeyReturnType<TKey>>;\r\nexport function useFragment<TKey extends KeyType>(\r\n    fragmentNode: GraphQLTaggedNode,\r\n    fragmentRef: TKey | null,\r\n): $Call<KeyReturnType<TKey>> | null;\r\nexport function useFragment<TKey extends ArrayKeyType>(\r\n    fragmentNode: GraphQLTaggedNode,\r\n    fragmentRef: TKey,\r\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>;\r\nexport function useFragment<TKey extends ArrayKeyType>(\r\n    fragmentNode: GraphQLTaggedNode,\r\n    fragmentRef: TKey | null,\r\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> {\r\n    const [data] = useOssFragment(fragmentNode, fragmentRef, false, FRAGMENT_NAME);\r\n    return data;\r\n}\r\n\r\nexport function useSuspenseFragment<TKey extends KeyType>(\r\n    fragmentNode: GraphQLTaggedNode,\r\n    fragmentRef: TKey,\r\n): $Call<KeyReturnType<TKey>>;\r\nexport function useSuspenseFragment<TKey extends KeyType>(\r\n    fragmentNode: GraphQLTaggedNode,\r\n    fragmentRef: TKey | null,\r\n): $Call<KeyReturnType<TKey>> | null;\r\nexport function useSuspenseFragment<TKey extends ArrayKeyType>(\r\n    fragmentNode: GraphQLTaggedNode,\r\n    fragmentRef: TKey,\r\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>>;\r\nexport function useSuspenseFragment<TKey extends ArrayKeyType>(\r\n    fragmentNode: GraphQLTaggedNode,\r\n    fragmentRef: TKey | null,\r\n): ReadonlyArray<$Call<ArrayKeyReturnType<TKey>>> {\r\n    const [data] = useOssFragment(fragmentNode, fragmentRef, true, FRAGMENT_NAME);\r\n    return data;\r\n}\r\n","import { GraphQLTaggedNode, OperationType } from 'relay-runtime';\r\nimport {\r\n    KeyType,\r\n    KeyTypeData,\r\n    PAGINATION_NAME,\r\n    ReturnTypePagination,\r\n    ReturnTypePaginationSuspense,\r\n} from './RelayHooksTypes';\r\nimport { useOssFragment } from './useOssFragment';\r\n\r\nexport function usePagination<TQuery extends OperationType, TKey extends KeyType>(\r\n    fragmentNode: GraphQLTaggedNode,\r\n    fragmentRef: TKey,\r\n): // tslint:disable-next-line no-unnecessary-generics\r\nReturnTypePagination<TQuery, TKey, KeyTypeData<TKey>>;\r\nexport function usePagination<TQuery extends OperationType, TKey extends KeyType>(\r\n    fragmentNode: GraphQLTaggedNode,\r\n    fragmentRef: TKey | null,\r\n): // tslint:disable-next-line no-unnecessary-generics\r\nReturnTypePagination<TQuery, TKey | null, KeyTypeData<TKey> | null> {\r\n    const [data] = useOssFragment(fragmentNode, fragmentRef, false, PAGINATION_NAME);\r\n    return data;\r\n}\r\n\r\nexport function usePaginationFragment<TQuery extends OperationType, TKey extends KeyType>(\r\n    fragmentNode: GraphQLTaggedNode,\r\n    fragmentRef: TKey,\r\n): // tslint:disable-next-line no-unnecessary-generics\r\nReturnTypePaginationSuspense<TQuery, TKey, KeyTypeData<TKey>>;\r\nexport function usePaginationFragment<TQuery extends OperationType, TKey extends KeyType>(\r\n    fragmentNode: GraphQLTaggedNode,\r\n    fragmentRef: TKey | null,\r\n): // tslint:disable-next-line no-unnecessary-generics\r\nReturnTypePaginationSuspense<TQuery, TKey | null, KeyTypeData<TKey> | null> {\r\n    const [data] = useOssFragment(fragmentNode, fragmentRef, true, PAGINATION_NAME);\r\n    return data;\r\n}\r\n","import { useEffect } from 'react';\r\nimport { OperationType } from 'relay-runtime';\r\nimport { RenderProps, LoadQuery } from './RelayHooksTypes';\r\nimport { useForceUpdate } from './useForceUpdate';\r\nimport { useRelayEnvironment } from './useRelayEnvironment';\r\n\r\nexport const usePreloadedQuery = <TOperationType extends OperationType = OperationType>(\r\n    loadQuery: LoadQuery,\r\n): RenderProps<TOperationType> => {\r\n    const forceUpdate = useForceUpdate();\r\n    const environment = useRelayEnvironment();\r\n\r\n    useEffect(() => {\r\n        return loadQuery.subscribe(forceUpdate);\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, [loadQuery]);\r\n\r\n    return loadQuery.getValue(environment) as RenderProps<TOperationType>;\r\n};\r\n","import { GraphQLTaggedNode, OperationType } from 'relay-runtime';\r\nimport {\r\n    KeyType,\r\n    KeyTypeData,\r\n    REFETCHABLE_NAME,\r\n    ReturnTypeRefetchNode,\r\n    ReturnTypeRefetchSuspenseNode,\r\n} from './RelayHooksTypes';\r\nimport { useOssFragment } from './useOssFragment';\r\n\r\nexport function useRefetchable<TQuery extends OperationType, TKey extends KeyType>(\r\n    fragmentInput: GraphQLTaggedNode,\r\n    fragmentRef: TKey,\r\n): // tslint:disable-next-line no-unnecessary-generics\r\nReturnTypeRefetchNode<TQuery, TKey, KeyTypeData<TKey>>;\r\nexport function useRefetchable<TQuery extends OperationType, TKey extends KeyType>(\r\n    fragmentInput: GraphQLTaggedNode,\r\n    fragmentRef: TKey | null,\r\n): // tslint:disable-next-line no-unnecessary-generics\r\nReturnTypeRefetchNode<TQuery, TKey, KeyTypeData<TKey> | null> {\r\n    const [data] = useOssFragment(fragmentInput, fragmentRef, false, REFETCHABLE_NAME);\r\n    return data;\r\n}\r\n\r\nexport function useRefetchableFragment<TQuery extends OperationType, TKey extends KeyType>(\r\n    fragmentInput: GraphQLTaggedNode,\r\n    fragmentRef: TKey,\r\n): // tslint:disable-next-line no-unnecessary-generics\r\nReturnTypeRefetchSuspenseNode<TQuery, TKey, KeyTypeData<TKey>>;\r\nexport function useRefetchableFragment<TQuery extends OperationType, TKey extends KeyType>(\r\n    fragmentInput: GraphQLTaggedNode,\r\n    fragmentRef: TKey | null,\r\n): // tslint:disable-next-line no-unnecessary-generics\r\nReturnTypeRefetchSuspenseNode<TQuery, TKey, KeyTypeData<TKey> | null> {\r\n    const [data] = useOssFragment(fragmentInput, fragmentRef, true, REFETCHABLE_NAME);\r\n    return data;\r\n}\r\n","import { useEffect } from 'react';\r\nimport { GraphQLSubscriptionConfig, requestSubscription, OperationType } from 'relay-runtime';\r\nimport {\r\n    SkipGraphQLSubscriptionConfig,\r\n    SkipSubscriptionConfig,\r\n    SubscriptionConfig,\r\n} from './RelayHooksTypes';\r\nimport { useRelayEnvironment } from './useRelayEnvironment';\r\n\r\nexport function useSubscription<TSubscriptionPayload extends OperationType = OperationType>(\r\n    config: GraphQLSubscriptionConfig<TSubscriptionPayload>,\r\n    opts?: SubscriptionConfig,\r\n): void;\r\nexport function useSubscription<TSubscriptionPayload extends OperationType = OperationType>(\r\n    config: SkipGraphQLSubscriptionConfig<TSubscriptionPayload>,\r\n    opts: SkipSubscriptionConfig,\r\n): void;\r\nexport function useSubscription<TSubscriptionPayload extends OperationType = OperationType>(\r\n    config: GraphQLSubscriptionConfig<TSubscriptionPayload>,\r\n    opts?: SubscriptionConfig,\r\n): void {\r\n    const environment = useRelayEnvironment();\r\n    const skip = opts && opts.skip;\r\n\r\n    useEffect(() => {\r\n        if (skip) {\r\n            return;\r\n        }\r\n        const { dispose } = requestSubscription(environment, config);\r\n        return dispose;\r\n    }, [environment, config, skip]);\r\n}\r\n"],"names":["ReactRelayContext","createRelayContext","React","forceCache","force","createOperation","gqlQuery","variables","cacheConfig","createOperationDescriptor","getRequest","fetchQuery","fetchResolver","_a","releaseQueryTimeout","query","promise","env","setLoading","_b","doRetain","disposeTemporary","_refetchSubscription","disposable","isLoading","error","updateLoading","loading","dispose","clearTemporaryRetain","disposeRequest","clearTimeout","unsubscribe","fetch","environment","operation","fetchPolicy","onComplete","onNext","renderPolicy","_e","request","identifier","retain","policy","queryStatus","check","status","hasFullQuery","snapshot","lookup","fragment","full","isNetwork","onlyStore","refetchSubscription_1","resolveNetworkPromise_1","cleanup_1","subscribe","complete","e","next","store","poll","start","subscription","Promise","resolve","getData","checkAndSuspense","suspense","useLazy","toThrow","setTimeout","cache","Map","getOrCreateQueryFetcher","networkCacheConfig","queryFetcher","has","get","QueryFetcher","setQuery","emptyforceUpdate","cacheConfigOverride","options","_this","node","resolveResult","forceUpdate","result","retry","this","data","fetcher","delete","disposeSnapshot","rootSubscription","skip","fetchHasReturned","_o","areEqual","getQuery","fetchKey","setForceUpdate","set","useForceUpdate","useRelayEnvironment","useInternalQuery","ref","useRef","current","useEffect","emptyFunction","internalLoadQuery","Error","reject","callback","getForceUpdate","getValue","resolveEnvironment","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","getValueAtPath","path","path_1","_i","key","Array","isArray","invariant","getStateFromConnection","direction","fragmentNode","connection","cursor","hasMore","_c","EDGES","PAGE_INFO","HAS_NEXT_PAGE","HAS_PREV_PAGE","END_CURSOR","START_CURSOR","edges","pageInfo","getRefetchMetadata","componentDisplayName","metadata","plural","refetchMetadata","refetch","refetchableRequest","default","fragmentRefPathInResponse","fragmentPathInResult","identifierField","getPaginationMetadata","paginationRequest","paginationMetadata","connectionPathInFragmentData","connectionMetadata","stream","getPromiseForActiveRequest","getFragmentResult","missData","isMissingData","map","some","name","unmounted","parentVariables","fragmentVariables","fragmentData","identifierValue","_selector","kind","selectors","owner","refetchVariables","id","pagination","fetcherNext","fetcherPrevious","fetcherRefecth","_environment","fragmentRef","isEquals","isEqualsFragmentRef","_fragmentRefRefetch","_fragmentRef","_idfragmentrefetch","getFragmentIdentifier","_fragment","resolverData","refreshHooks","UNSTABLE_renderPolicy","count","loadMore","isRequestActive","extraVariables","UNSTABLE_extraVariables","baseVariables","paginationVariables","backwardMetadata","forwardMetadata","paginationVariables_1","getPaginationVariables","undefined","refetchable","_loading","FragmentResolver","prevFragment","prevIDs","getDataIDsFromFragment","nextIDs","getFragmentVariables","fRef","getVariablesFromFragment","idfragment","_idfragment","getSelector","selector","fragmentOwner","networkPromise","getOperationTracker","getPromiseForPendingOperationsAffectingOwner","getPromiseForPendingOperationAffectingOwner","_getAndSavePromiseForFragmentRequestInFlight","parentQueryName","params","then","catch","_error","displayName","hasNext","hasPrevious","isLoadingNext","errorNext","isLoadingPrevious","errorPrevious","loadNext","loadPrevious","_disposable","renderedSnapshot","dataSubscriptions","forEach","idx","push","latestSnapshot","useOssFragment","resolver","setUnmounted","useMemo","getFragment","useCallback","useState","props","context","Provider","value","children","mutation","userConfig","state","setState","isMounted","useMounted","relayEnvironment","resolvedEnvironment","configs","uploadables","onCompleted","onError","optimisticUpdater","optimisticResponse","updater","config","mergedConfig","handleError","commitMutation","response","errors","loadQuery","fragmentInput","opts"],"mappings":"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"}